// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: events.sql

package db

import (
	"context"
	"time"
)

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    date,
    time,
    forecast,
    impact,
    last_update,
    name,
    previous,
    region
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, date, time, forecast, impact, last_update, name, previous, region
`

type CreateEventParams struct {
	Date       time.Time `json:"date"`
	Time       time.Time `json:"time"`
	Forecast   string    `json:"forecast"`
	Impact     string    `json:"impact"`
	LastUpdate int32     `json:"last_update"`
	Name       string    `json:"name"`
	Previous   string    `json:"previous"`
	Region     string    `json:"region"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.Date,
		arg.Time,
		arg.Forecast,
		arg.Impact,
		arg.LastUpdate,
		arg.Name,
		arg.Previous,
		arg.Region,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Time,
		&i.Forecast,
		&i.Impact,
		&i.LastUpdate,
		&i.Name,
		&i.Previous,
		&i.Region,
	)
	return i, err
}

const getEventByDate = `-- name: GetEventByDate :many
SELECT id, date, time, forecast, impact, last_update, name, previous, region FROM events
WHERE date = $1
`

func (q *Queries) GetEventByDate(ctx context.Context, date time.Time) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Time,
			&i.Forecast,
			&i.Impact,
			&i.LastUpdate,
			&i.Name,
			&i.Previous,
			&i.Region,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByRegion = `-- name: GetEventsByRegion :many
SELECT id, date, time, forecast, impact, last_update, name, previous, region FROM Events 
WHERE region = $1
ORDER BY date DESC
LIMIT $2
`

type GetEventsByRegionParams struct {
	Region string `json:"region"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) GetEventsByRegion(ctx context.Context, arg GetEventsByRegionParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByRegion, arg.Region, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Time,
			&i.Forecast,
			&i.Impact,
			&i.LastUpdate,
			&i.Name,
			&i.Previous,
			&i.Region,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsList = `-- name: GetEventsList :many
SELECT id, date, time, forecast, impact, last_update, name, previous, region FROM events
ORDER BY date DESC
LIMIT $1
`

func (q *Queries) GetEventsList(ctx context.Context, limit int32) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsList, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Time,
			&i.Forecast,
			&i.Impact,
			&i.LastUpdate,
			&i.Name,
			&i.Previous,
			&i.Region,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsWithFilter = `-- name: GetEventsWithFilter :many
SELECT id, date, time, forecast, impact, last_update, name, previous, region FROM events
WHERE 
    region = $1
AND
    impact = $2 
AND
    impact = $3
`

type GetEventsWithFilterParams struct {
	Region   string `json:"region"`
	Impact   string `json:"impact"`
	Impact_2 string `json:"impact_2"`
}

func (q *Queries) GetEventsWithFilter(ctx context.Context, arg GetEventsWithFilterParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsWithFilter, arg.Region, arg.Impact, arg.Impact_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Time,
			&i.Forecast,
			&i.Impact,
			&i.LastUpdate,
			&i.Name,
			&i.Previous,
			&i.Region,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastEventDate = `-- name: GetLastEventDate :one
SELECT date FROM events
ORDER BY date DESC LIMIT 1
`

func (q *Queries) GetLastEventDate(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getLastEventDate)
	var date time.Time
	err := row.Scan(&date)
	return date, err
}
