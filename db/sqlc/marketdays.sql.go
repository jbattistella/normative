// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.0
// source: marketdays.sql

package db

import (
	"context"
	"time"
)

const createMarketDay = `-- name: CreateMarketDay :one
INSERT INTO market_days (
    date,
    open,
    high,
    low,
    last,
    range,
    volume,
    market
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, date, open, high, low, last, range, volume, market
`

type CreateMarketDayParams struct {
	Date   time.Time `json:"date"`
	Open   float64   `json:"open"`
	High   float64   `json:"high"`
	Low    float64   `json:"low"`
	Last   float64   `json:"last"`
	Range  float64   `json:"range"`
	Volume float64   `json:"volume"`
	Market string    `json:"market"`
}

func (q *Queries) CreateMarketDay(ctx context.Context, arg CreateMarketDayParams) (MarketDay, error) {
	row := q.db.QueryRowContext(ctx, createMarketDay,
		arg.Date,
		arg.Open,
		arg.High,
		arg.Low,
		arg.Last,
		arg.Range,
		arg.Volume,
		arg.Market,
	)
	var i MarketDay
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Open,
		&i.High,
		&i.Low,
		&i.Last,
		&i.Range,
		&i.Volume,
		&i.Market,
	)
	return i, err
}

const getAveageRange = `-- name: GetAveageRange :one
SELECT AVG(range) 
FROM market_days
LIMIT $1
`

func (q *Queries) GetAveageRange(ctx context.Context, limit int32) (float64, error) {
	row := q.db.QueryRowContext(ctx, getAveageRange, limit)
	var avg float64
	err := row.Scan(&avg)
	return avg, err
}

const getLastMarketRecord = `-- name: GetLastMarketRecord :one
SELECT id, date, open, high, low, last, range, volume, market FROM market_days
ORDER BY date ASC
LIMIT 1
`

func (q *Queries) GetLastMarketRecord(ctx context.Context) (MarketDay, error) {
	row := q.db.QueryRowContext(ctx, getLastMarketRecord)
	var i MarketDay
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Open,
		&i.High,
		&i.Low,
		&i.Last,
		&i.Range,
		&i.Volume,
		&i.Market,
	)
	return i, err
}

const getMarketDataByDate = `-- name: GetMarketDataByDate :one
SELECT id, date, open, high, low, last, range, volume, market FROM market_days
WHERE date = $1
`

func (q *Queries) GetMarketDataByDate(ctx context.Context, date time.Time) (MarketDay, error) {
	row := q.db.QueryRowContext(ctx, getMarketDataByDate, date)
	var i MarketDay
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.Open,
		&i.High,
		&i.Low,
		&i.Last,
		&i.Range,
		&i.Volume,
		&i.Market,
	)
	return i, err
}

const getMarketDataByDateRange = `-- name: GetMarketDataByDateRange :many
SELECT id, date, open, high, low, last, range, volume, market FROM market_days
WHERE date BETWEEN $1 AND $2
`

type GetMarketDataByDateRangeParams struct {
	Date   time.Time `json:"date"`
	Date_2 time.Time `json:"date_2"`
}

func (q *Queries) GetMarketDataByDateRange(ctx context.Context, arg GetMarketDataByDateRangeParams) ([]MarketDay, error) {
	rows, err := q.db.QueryContext(ctx, getMarketDataByDateRange, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MarketDay
	for rows.Next() {
		var i MarketDay
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Last,
			&i.Range,
			&i.Volume,
			&i.Market,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMarketDataByDays = `-- name: GetMarketDataByDays :many
SELECT id, date, open, high, low, last, range, volume, market FROM market_days
ORDER BY date DESC
LIMIT $1
`

func (q *Queries) GetMarketDataByDays(ctx context.Context, limit int32) ([]MarketDay, error) {
	rows, err := q.db.QueryContext(ctx, getMarketDataByDays, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MarketDay
	for rows.Next() {
		var i MarketDay
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Open,
			&i.High,
			&i.Low,
			&i.Last,
			&i.Range,
			&i.Volume,
			&i.Market,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
